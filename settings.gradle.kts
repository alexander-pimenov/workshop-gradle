rootProject.name = "workshop-gradle"

//так же здесь в settings можно указать блок plugins {...}, который будет
//потом переиспользоваться в build.gradle.kts уже без указания версии
//Этот блок здесь обязательно идет первым!!!
//apply false - скажет записать плагин в classpath, но сам плагин запускаться не будет.
plugins {
    //id("ru.sberbank.uvz3.gradle.jvm") version "latest.release" apply false
}
//gradle - это самый рут и тут пишем чтоб ко всем проектам
//добавил лисенер beforeEvaluate
gradle.allprojects {
    //это типичный для билдскриптов колбэк, что бы посмотреть, там
    //когда проект еще не сконфигурирован
    //т.е. до этапа конфигурации
    beforeEvaluate {
        println("Before project evaluated") //Оценка проекта
    }
}

//можем посмотреть таскграф, он позволяет добавлять лисенеры на
//все таски
gradle.taskGraph.afterTask {
    println("---Task completed $this---")
}

//Через includeBuild мы подключаем папки, в которых расположены кастомные классы
//тасок. И таких папок может быть много и они могут в разных местах подключаться.
//includeBuild("buildSrc") - но buildSrc это зарезервированное имя и gradle и так эту папку увидит
//После рефреша папка 'buildSrc' будет восприниматься Gradle, как еще один проект.

//включим наши consumer и producer в проект, т.е. в нашу сборку
include("consumer", "producer")

//Так можно подключить все нужные зависимости для выполнения тасок:
//например, Jackson, Guava и т.д.
//Но это считается антипаттерн, т.к. рут знает все зависимости которые
//должны попасть в classpath билда (не выполнение самой программы, а работы билда)
//для всех модулей.
//От этого подхода уходят, создавая плагины и вынося их в отдельные проекты,
//т.е. опубликовываем как внешние плагины.
//И внешние плагины подключаются в блоке plugins{...} и он должен быть первым (так принято).
buildscript {
    dependencies {

    }
}
